!pip install qiskit matplotlib --quiet
import numpy as np
import matplotlib.pyplot as plt
from qiskit import QuantumCircuit

# -------------------------
# Physical constants
# -------------------------
hbar = 1.054571817e-34  # J·s
e = 1.602176634e-19     # C
h = 2 * np.pi * hbar

# -------------------------
# Base junction parameters
# -------------------------
base_params = [
    {"C": 10e-15, "R_N": 10e3, "Delta": 200e-6 * e},
    {"C": 10e-15, "R_N": 10e3, "Delta": 200e-6 * e},
    {"C": 10e-15, "R_N": 10e3, "Delta": 200e-6 * e},
]

# Noise parameters (static Gaussian)
sigma_EJ = 0.02  # 2% standard deviation
sigma_EC = 0.02  # 1% standard deviation
rng = np.random.default_rng(42)


# -------------------------
# Helper physical conversions
# -------------------------
def compute_Ic(R_N, Delta):
    """Compute Josephson critical current I_c."""
    return (np.pi * Delta) / (2 * e * R_N)

def EJ_GHz(Ic):
    """Convert Josephson energy to GHz."""
    EJ_J = hbar * Ic / (2 * e)
    return EJ_J / h / 1e9

def EC_GHz(C):
    """Convert charging energy to GHz."""
    EC = e**2 / (2 * C)
    return EC / h / 1e9

def approx_w01(EJ, EC):
    """
    Approximate the ω01 transition frequency (GHz)
    using the transmon energy level formula.
    """
    return np.sqrt(8 * EJ * EC) - EC  # GHz


# -------------------------
# Core computation
# -------------------------
def compute_detunings_noisy(params):
    """Compute pairwise detuning with Gaussian noise (GHz)."""
    EJ_list = []
    EC_list = []
    for p in params:
        Ic = compute_Ic(p["R_N"], p["Delta"])
        EJ = EJ_GHz(Ic)
        EC = EC_GHz(p["C"])
        EJ *= (1 + rng.normal(0, sigma_EJ))
        EC *= (1 + rng.normal(0, sigma_EC))
        EJ_list.append(EJ)
        EC_list.append(EC)

    w01 = approx_w01(np.array(EJ_list), np.array(EC_list))
    pairs, dets = [], []
    for i in range(len(w01)):
        for j in range(i + 1, len(w01)):
            pairs.append(f"{i}-{j}")
            dets.append(abs(w01[i] - w01[j]))
    return pairs, dets

# -------------------------
# Parameter sweep
# -------------------------
def sweep_parameter(param_name, values, qubit_idx=0):
    all_detunings = []
    pairs_ref = None
    for val in values:
        params = [dict(p) for p in base_params]
        params[qubit_idx][param_name] = val
        pairs, dets = compute_detunings_noisy(params)
        if pairs_ref is None:
            pairs_ref = pairs
            for _ in pairs:
                all_detunings.append([])
        for i, d in enumerate(dets):
            all_detunings[i].append(d)
    return pairs_ref, np.array(all_detunings)

# -------------------------
# Plotting utility
# -------------------------
def plot_sweep(x_values, pairs, detuning_matrix, xlabel, title):
    plt.figure(figsize=(7,4))
    for i, pair in enumerate(pairs):
        plt.plot(x_values, detuning_matrix[i], label=f"Pair {pair}")
    plt.xlabel(xlabel)
    plt.ylabel("Detuning (GHz)")
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

# -------------------------
# Example usage (Qiskit-integrated workflow)
# -------------------------
if __name__ == "__main__":
    print("Running Qiskit-based transmon detuning sweep...")

    # Sweep C (fF)
    C_values = np.linspace(5e-15, 20e-15, 100)
    pairs, mat_C = sweep_parameter("C", C_values, qubit_idx=0)
    plot_sweep(C_values*1e15, pairs, mat_C,
               "Qubit 0 Capacitance C (fF)",
               "Effect of Capacitance on Pairwise Detuning")

    # Sweep Delta (µeV)
    Delta_values = np.linspace(100e-6*e, 250e-6*e, 100)
    pairs, mat_D = sweep_parameter("Delta", Delta_values, qubit_idx=0)
    plot_sweep(Delta_values/e*1e6, pairs, mat_D,
               "Qubit 0 Delta (µeV)",
               "Effect of Δ on Pairwise Detuning")

    # Sweep R_N (kΩ)
    Rn_values = np.linspace(5e3, 25e3, 100)
    pairs, mat_R = sweep_parameter("R_N", Rn_values, qubit_idx=0)
    plot_sweep(Rn_values/1e3, pairs, mat_R,
               "Qubit 0 R_N (kΩ)",
               "Effect of R_N on Pairwise Detuning")

    print("✅ Sweep complete.")

